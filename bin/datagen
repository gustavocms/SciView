#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
Bundler.require(:default, :development)

require_relative '../lib/datagen'

# A CLI tool for generating sample datasets
class DataGenCLI < Thor
  desc 'create KEY', 'Generate a test dataset for a given key'
  option :count, required: true, type: :numeric
  option :start_time
  option :end_time
  option :type, enum: %w(sin square line power)
  option :force, alias: 'f', type: :boolean
  def create(key)
    count = options[:count]
    start_time = Chronic.parse(options[:start_time]) || Time.now
    end_time = Chronic.parse(options[:end_time]) || start_time + (0.001 * count)
    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])

    check_existing_set(client, key, options)

    say "Creating #{count} data points starting at #{start_time}..."
    series = client.create_series(key)
    data = generate_data(start_time, end_time, count)

    client.write_key(series.key, data)
  end

  desc 'sample1 KEY', 'Generate the first sample dataset described in SCIV-4'
  option :start_time
  def sample1(key)
    start_time = Chronic.parse(options[:start_time]) || Time.now
    end_time = start_time + (30 * 60)

    spike_up = DataGen::Normal.new(value: 1_000, stddev: 15, delay: 10 * 60)
    spike_down = DataGen::Normal.new(value: -1_000, stddev: 15, delay: 20 * 60)
    baseline = DataGen::Line.new(offset: 10, tolerance: 1)
    series = DataGen::TimeSeries.new(baseline + spike_up + spike_down,
                                     start_time: start_time, end_time: end_time)
    series.frequency = 1

    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])
    check_existing_set(client, key, force: true)

    db_series = client.create_series(key)
    data = series.map { |t, v| TempoDB::DataPoint.new(t, v) }
    data.each_slice(1_000).each do |d|
      $stderr.puts "Writing #{d.length} data points."
      client.write_key(db_series.key, d)
    end
  end

  private

  def check_existing_set(client, key, options)
    unless client.get_series(key: key).empty?
      if options[:force]
        client.delete_series(key: key)
      else
        say "Series for key \"#{key}\" already exists. (Use --force to overwrite)", :red
        return
      end
    end
  end

  def generate_data(start_time, end_time, count)
    interval = (end_time.to_f - start_time.to_f) / count
    Range.new(start_time, end_time).step(interval).map do |t|
      TempoDB::DataPoint.new(Time.at(t).utc, rand(100))
    end
  end
end

DataGenCLI.start(ARGV)

# vim:ft=ruby
