#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
Bundler.require(:default, :development)

require_relative '../lib/datagen'

# A CLI tool for generating sample datasets
class DataGenCLI < Thor
  desc 'create KEY', 'Generate a test dataset for a given key'
  option :count, required: true, type: :numeric
  option :start_time
  option :end_time
  option :type, enum: %w(sin square line power)
  option :force, alias: 'f', type: :boolean
  def create(key)
    count = options[:count]
    start_time = Chronic.parse(options[:start_time]) || Time.now
    end_time = Chronic.parse(options[:end_time]) || start_time + (0.001 * count)
    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])

    check_existing_set(client, key, options)

    say "Creating #{count} data points starting at #{start_time}..."
    series = client.create_series(key)
    data = generate_data(start_time, end_time, count)

    client.write_key(series.key, data)
  end

  desc 'sample1 KEY', 'Generate the first sample dataset described in SCIV-4'
  def sample1(key)
    start_time = Time.now
    end_time = start_time + (30 * 60)

    spike_up = DataGen::Normal.new(value: 1_000, stddev: 15, delay: 10 * 60)
    spike_down = DataGen::Normal.new(value: -1_000, stddev: 15, delay: 20 * 60)
    baseline = DataGen::Line.new(offset: 10, tolerance: 1)
    series = DataGen::TimeSeries.new(baseline + spike_up + spike_down,
                                     start_time: start_time, end_time: end_time)
    series.frequency = 1

    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])
    check_existing_set(client, key, force: true)

    db_series = client.create_series(key)
    data = series.map { |t, v| TempoDB::DataPoint.new(t, v) }
    data.each_slice(1_000).each do |d|
      say "Writing #{d.length} data points."
      client.write_key(db_series.key, d)
    end
  end

  desc 'sample2 KEY', 'Generate the second sample dataset described in SCIV-4'
  def sample2(key)
    start_time = Time.now
    end_time = start_time + (30 * 60)

    position = DataGen::Power.new(power: 1.5) +
      DataGen::Sin.new(period: 600, amplitude: 10)
    velocity = DataGen::Power.new(power: 0.5, scale: 1.5) +
      DataGen::Sin.new(period: 600, delay: 150, amplitude: 10)
    acceleration = DataGen::Power.new(power: -0.5, scale: 0.75) +
      DataGen::Sin.new(period: 600, delay: 300, amplitude: 10)
    pos_series = DataGen::TimeSeries.new(position, start_time: start_time,
                                         end_time: end_time)
    vel_series = DataGen::TimeSeries.new(velocity, start_time: start_time,
                                         end_time: end_time)
    acc_series = DataGen::TimeSeries.new(acceleration, start_time: start_time,
                                         end_time: end_time)
    pos_series.frequency = vel_series.frequency = acc_series.frequency = 1

    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])

    [[pos_series, {name: "Position", frequency: "1 Hz"}, %w|sample red|],
     [vel_series, {name: "Velocity", frequency: "1 Hz"}, %w|sample blue|],
     [acc_series, {name: "Acceleration", frequency: "1 Hz"}, %w|sample green|]]
      .each do |(data, attrs, tags)|
      sub_series_key = "#{key}.#{attrs[:name]}"
      check_existing_set(client, sub_series_key, force: true)
      sub_series = client.create_series(sub_series_key)
      sub_series.attributes = attrs
      sub_series.tags = tags
      client.update_series(sub_series)
      say "Writing data for key: #{sub_series_key}"
      client.write_key(sub_series_key, data.map { |t, v| TempoDB::DataPoint.new(t, v) })
    end
  end

  desc 'sample3 KEY', 'Generate the third sample dataset described in SCIV-4'
  def sample3(key)
    # Three series that are from different gauges all capturing the same data... but there
    # is a 1% error rate and some data is missing from each gauge. Include tags/attributes
    # for easy identification.
    start_time = Time.now
    end_time = start_time + (30 * 60)
    gen = DataGen::Square.new(period: 500, pct_error: 1) +
      DataGen::Sin.new(period: 300, pct_error: 1) +
      DataGen::Line.new(slope: 0.004, pct_error: 1, offset: 5)

    ser1 = DataGen::TimeSeries.new(gen, start_time: start_time, end_time: end_time,
                                   gap_freq: 0.02, gap_size: 50)
    ser2 = DataGen::TimeSeries.new(gen, start_time: start_time, end_time: end_time,
                                   gap_freq: 0.01, gap_size: 100)
    ser3 = DataGen::TimeSeries.new(gen, start_time: start_time, end_time: end_time,
                                   gap_freq: 0.10, gap_size: 10)
    ser1.frequency = ser2.frequency = ser3.frequency = 3

    client = TempoDB::Client.new(ENV['TEMPODB_API_KEY'], ENV['TEMPODB_API_SECRET'])

    [ser1, ser2, ser3].each.with_index do |data, idx|
      sub_series_key = "#{key}.#{idx}"
      check_existing_set(client, sub_series_key, force: true)
      say "Writing data series ##{idx + 1}."
      client.write_key(sub_series_key, data.map { |t, v| TempoDB::DataPoint.new(t, v) })
    end
  end


  private

  def check_existing_set(client, key, options)
    unless client.get_series(key: key).empty?
      if options[:force]
        client.delete_series(key: key)
      else
        say "Series for key \"#{key}\" already exists. (Use --force to overwrite)", :red
        return
      end
    end
  end

  def generate_data(start_time, end_time, count)
    interval = (end_time.to_f - start_time.to_f) / count
    Range.new(start_time, end_time).step(interval).map do |t|
      TempoDB::DataPoint.new(Time.at(t).utc, rand(100))
    end
  end
end

DataGenCLI.start(ARGV)

# vim:ft=ruby
