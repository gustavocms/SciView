(function(window, document) {

  // Create all modules and define dependencies to make sure they exist
  // and are loaded in the correct order to satisfy dependency injection
  // before all nested files are concatenated by Grunt

  // Config
  angular.module('ngS3upload.config', []).
    value('ngS3upload.config', {
        debug: true
    }).
    config(['$compileProvider', function($compileProvider){
      if (angular.isDefined($compileProvider.urlSanitizationWhitelist)) {
        $compileProvider.urlSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/);
      } else {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|data):/);
      }
    }]);

  // Modules
  angular.module('ngS3upload.directives', []);
  angular.module('ngS3upload',
      [
          'ngS3upload.config',
          'ngS3upload.directives',
          'ngS3upload.services',
          'ngSanitize'
      ]);
  angular.module('ngS3upload.services', []).
    service('S3Uploader', ['$http', '$q', '$window', function ($http, $q, $window) {
      this.uploads = 0;
      var self = this;

      this.getUploadOptions = function (uri) {
        var deferred = $q.defer();
        $http.get(uri).
          success(function (response, status) {
            deferred.resolve(response);
          }).error(function (error, status) {
            deferred.reject(error);
          });

        return deferred.promise;
      };

      this.randomString = function (length) {
        var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        var result = '';
        for (var i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];

        return result;
      };


      this.upload = function (scope, uri, key, acl, type, accessKey, policy, signature, file, item) {
        var deferred = $q.defer();
        scope.attempt = true;

        var fd = new FormData();
        fd.append('key', key);
        fd.append('acl', acl);
        fd.append('Content-Type', file.type);
        fd.append('AWSAccessKeyId', accessKey);
        fd.append('policy', policy);
        fd.append('signature', signature);
        fd.append("file", file);

        var xhr = new XMLHttpRequest();
        xhr.upload.addEventListener("progress", uploadProgress, false);
        xhr.addEventListener("load", uploadComplete, false);
        xhr.addEventListener("error", uploadFailed, false);
        xhr.addEventListener("abort", uploadCanceled, false);
        scope.$emit('s3upload:start', xhr);

        item.xhr = xhr

        // Define event handlers
        function uploadProgress(e) {
          if (e.lengthComputable) {
            item.progress = Math.round(e.loaded * 100 / e.total);
          } else {
            item.progress = 'unable to compute';
          }
          var msg = {type: 'progress', value: scope.progress};
          scope.$emit('s3upload:progress', msg);
          if (typeof deferred.notify === 'function') {
            deferred.notify(msg);
          }
        }
        function uploadComplete(e) {
          var xhr = e.srcElement || e.target;
          scope.$apply(function () {
            self.uploads--;
            scope.uploading = false;
            if (xhr.status === 204) { // successful upload
              scope.success = true;
              deferred.resolve(xhr);
              scope.$emit('s3upload:success', xhr);
            } else {
              scope.success = false;
              deferred.reject(xhr);
              scope.$emit('s3upload:error', xhr);
            }
          });
        }
        function uploadFailed(e) {
          var xhr = e.srcElement || e.target;
          scope.$apply(function () {
            self.uploads--;
            scope.uploading = false;
            scope.success = false;
            deferred.reject(xhr);
            scope.$emit('s3upload:error', xhr);
          });
        }
        function uploadCanceled(e) {
          var xhr = e.srcElement || e.target;
          self.uploads--;
          scope.uploading = false;
          scope.success = false;
          deferred.reject(xhr);
          scope.$emit('s3upload:abort', xhr);
        }

        // Send the file
        scope.uploading = true;
        this.uploads++;
        xhr.open('POST', uri, true);
        xhr.send(fd);

        return deferred.promise;
      };

      this.isUploading = function () {
        return this.uploads > 0;
      };
    }]);
  angular.module('ngS3upload.directives', []).
    directive('s3Upload', ['$parse', 'S3Uploader', function ($parse, S3Uploader) {
      return {
        restrict: 'AEC',
        require: '?ngModel',
        transclude: false,
        scope: true,
        templateUrl: "<%= asset_path('sciview/partials/uploader.html') %>",
        controller: ['$scope', '$element', '$attrs', '$transclude', function ($scope, $element, $attrs, $transclude) {
          $scope.attempt = false;
          $scope.success = false;
          $scope.uploading = false;
          $scope.uploads = [];
          $scope.uploadAll = ''

          var index   = 0

          var opts = angular.extend({}, $scope.$eval($attrs.s3UploadOptions || $attrs.options));
          opts = angular.extend({
            submitOnChange: true,
            getOptionsUri: '/getS3Options',
            acl: 'public-read',
            uploadingKey: 'uploading',
            folder: ''
          }, opts);

          var button = angular.element($element.children()[0]),
              file   = angular.element($element.find("input")[0]);
            button.bind('click', function (e) {
            file[0].click();
          });

          $scope.barClass = function () {
            return {
              "bar-success": $scope.attempt && !$scope.uploading && $scope.success
            };
          };


          validMimeTypes = $attrs.validTypes
  
          var checkSize, isTypeValid;

          checkSize = function(size) {
            var _ref;
            if (((_ref = $attrs.maxFileSize) === (void 0) || _ref === '') || (size / 1024) / 1024 < $attrs.maxFileSize) {
              return true;
            } else {
              alert("File must be smaller than " + $attrs.maxFileSize + " MB");
              return false;
            }
          };

          isTypeValid = function(type) {
            if ((validMimeTypes === (void 0) || validMimeTypes === '') || validMimeTypes.indexOf(type) > -1) {
              return true;
            } else {
              alert("Invalid file type.  File must be one of following types " + validMimeTypes);
              return false;
            }
          };

          isNotQueued = function(name) {
            
            if ( $scope.uploads.some(function(el) { return el['name'] == name } ) ) {
              alert("This file is already queued for upload please reaname the file if you think this is a mistake");
              return false;              
            } else {
              return true
            }
          };


          setUploadAll = function() {
            if( $scope.uploads.some( function(item) { return item.status.upload === 'waiting' }) ) {
              $scope.uploadAll = "Upload All";
            } else {
              $scope.uploadAll = "Finished"
            };
          };

          $scope.queueFile = function(file) {
            name = file.name;
            type = file.type;
            size = file.size;
            var ext = name.split('.').pop();

            var fileObj = {};
            fileObj.name = name;
            fileObj.status = { upload: 'waiting' };
            fileObj.file = file;
            fileObj.progress = 0

            $scope.$apply(function(){
              if (isNotQueued(name) && checkSize(size) && isTypeValid(type)) {
                $scope.uploads.push(fileObj);
              }
              setUploadAll()
            });
          }          

          // Choosing file from button
          $element.bind('change', function (nVal) {
            
            $scope.queueFile(file[0].files[0]);
          });

          // Drag n Drop

          var processDragOverOrEnter = function(event) {
            if (event !== null) {
              event.preventDefault();
            }
            event.originalEvent.dataTransfer.effectAllowed = 'copy';
            return false;
          };

          $element.bind('dragover', processDragOverOrEnter);

          $element.bind('dragenter', processDragOverOrEnter);


          $element.bind('drop', function(event) {
            var file, name, reader, size, type;
            if (event !== null) {
              event.preventDefault();
            }

            files = event.originalEvent.dataTransfer.files;
            for (i = 0; i < files.length; i++) {
              (function(file) {
                reader = new FileReader();
                reader.onload = function(evt) {
                  $scope.queueFile(file);
                };
                reader.readAsDataURL(file);
              })(files[i]);
            };
            return false;
          });


          // remove upload

          $scope.stopUpload = function(item) {
            index = $scope.uploads.indexOf(item)
            if(index != -1) {
              $scope.uploads.splice(index, 1);
            }
            setUploadAll()
          }

          // upload file

          $scope.uploadItem = function(item) {
            uploadFile(item)
          };

          $scope.cancelUpload = function(item) {
            if (item.status.upload === 'uploading') {
              item.xhr.abort()
              item.status.upload = 'canceled'
            } else {
              $scope.stopUpload(item)
            };
          }

          var uploadFile = function (item) {
            var file = item.file
            item.status.upload = 'uploading'
            S3Uploader.getUploadOptions(opts.getOptionsUri).then(function (s3Options) {
              var s3Uri = 'https://' + s3Options.bucket + '.s3.amazonaws.com/';
              var key = s3Options.folder + (new Date()).getTime() + '-' + S3Uploader.randomString(16) + "." + file.name.split('.').pop();;
              uploader = S3Uploader.upload($scope,
                  s3Uri,
                  key,
                  opts.acl,
                  file.type,
                  s3Options.key,
                  s3Options.policy,
                  s3Options.signature,
                  file,
                  item
                ).then(function () {
                  if (item.status.upload !== 'canceled') {
                    item.status.upload = 'done';
                  };
                }, function () {
                  if (item.status.upload !== 'canceled') {
                    item.status.upload = 'done';
                  };
                });
            }, function (error) {
              throw Error("Can't receive the needed options for S3 " + error);
            });

          };          


        }]
    }

  }]);
})(window, document);